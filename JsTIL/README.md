

> 자바스크립트란?

> 정의  

자바스크립트는 웹페이지에 생동감을 불어넣기 위해 만들어진 프로그래밍 언어
자바스크립트로 작성한 프로그램을 스크립트(script) 라고 부르며, 스크립트는 웹페이지의 HTML 안에 작성할 수 있는데, 웹페이지를 불러올 때 스크립트가 자동으로 실행된다.
브라우저엔 '자바스크립트 가상 머신’이라 불리는 엔진이 내장되어 있으며 이 가상 머신을 통해 브라우저에서 스크립트 언어를 읽고 전환하여 사용한다.

```
> 엔진은 어떻게 동작하는가??

간단하게 순서를 보면 아래와 같다.     
엔진(브라우저라면 내장 엔진)이 스크립트를 읽습니다(파싱).  
읽어 들인 스크립트를 기계어로 전환합니다(컴파일).  
기계어로 전환된 코드가 실행됩니다. 기계어로 전환되었기 때문에 실행 속도가 빠릅니다.  
엔진은 프로세스 각 단계마다 최적화를 진행합니다. 심지어 컴파일이 끝나고 실행 중인 코드를 감시하면서, 이 코드로 흘러가는 데이터를 분석하고, 분석 결과를 토대로 기계어로 전환된 코드를 다시 최적화하기도 합니다. 이런 과정을 거치면 스크립트 실행 속도는 더욱 더 빨라집니다.

```
> (ECMA 262 명세서 - 심도 있는 자바스크립트 문서)  
  
src 속성이 있으면 태그 내부의 코드는 무시됩니다.  
script 태그는 src 속성과 내부 코드를 동시에 가지지 못합니다.  
  
> 엄격모드란 ?
  
 - ECMAScript5(ES5)가 등장하기 전까지 있었던 javascript의 여러가지 불완전한 문법이 기존사이트에 영원히 박제되는 경우가 있었다.  
 - 해당사항을 극복하더라도, 호환성 문제를 해결하기위해 엄격모드에서만 해당 변경사항이 활성화 되도록 해놓았다.  
 - 'use strict' 는 최상단에 위치시켜야한다. 그리고 취소할 수 없다.  
 - 모던자바스크립트에는 class나 import등의 구조가 존재하는데, 이를 사용하면 자동으로 적용이 된다.  
  
  
> useStrict ? 
  
지시자 "use strict", 혹은 'use strict', 이 지시자가 스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작합니다.   
자바스크립트 엔진을 이전 방식으로 되돌리는 "no use strict"같은 지시자는 존재하지 않습니다.   
일단 엄격 모드가 적용되면 돌이킬 방법은 없습니다.   

---  

> var ? let ?  

var는 let과 거의 동일하게 동작합니다. var도 let처럼 변수를 선언하는 데 쓰이죠. 다만 var는 ‘오래된’ 방식입니다.  
거의 동일하게 작동한다면 그 작은 차이는 무엇일까, 
- var로 선언한 변수는 블록 스코프가 아닌 '함수 수준 스코프'를 갖습니다.  
- var 선언은 함수가 시작되는 시점(전역 공간에선 스크립트가 시작되는 시점)에서 처리됩니다.  

> null

자바스크립트의 null은 자바스크립트 이외 언어의 null과 성격이 다릅니다. 다른 언어에선 null을 '존재하지 않는 객체에 대한 참조’나 '널 포인터(null pointer)'를 나타낼 때 사용합니다.   
하지만 자바스크립트에선 null을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.   
let age = null;은 나이(age)를 알 수 없거나 그 값이 비어있음을 보여줍니다.  

---

> typeof 연산자  

typeof 연산자는 인수의 자료형을 반환합니다. 자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용합니다.  
typeof 연산자는 두 가지 형태의 문법을 지원합니다.  

 - typeof(value)  
 - typeof value  

두가지 모두 결과는 같습니다.

> prompt 

브라우저에서 제공하는 prompt 함수는 두 개의 인수를 받습니다.  
```javascript
  result = prompt(title, [default]);
```
title - user에게 보여줄 문자열, default - 입력필드의 초깃값  

> confirm 대화상자

```javascript
  const result = confirm('당신이 맞습니까?');
  alert(result);
```

확인을 누를시 true, 아닐시 false를 출력한다.  

> 형 변환  

- 문자형으로 변환 `String(value)`

- number 형식으로 변환 `Number(value)`

- Boolean형식으로 변환 
 1. Boolean(1) - true
 2. Boolean(0) - false
 3. Boolean('hi') - true
 4. Boolean('') - false

---

> 배열

* 배열의 생성

- 리터럴 생성
`let array = [1,2,3]`

- Array 클래스 생성
`let array = new Array`
`let array = new Array(10)`
`let array = new Array(1,2,3)`

- 배열 함수

`concat`
  * 기존 배열 변경 x 
  * 추가된 새로운 배열 반환
  ```javascript
    const array1 = ['a', 'b', 'c'];
    const array2 = ['d', 'e', 'f'];
    const array3 = array1.concat(array2);

  ```
`join`
  * .join()은 배열의 원소들을 연결하여 하나의 값으로 만듭니다.  
  
`pop`
  * pop() 메서드는 배열에서 마지막 요소를 제거하고 그 요소를 반환합니다.  
  
`push`

`reverse`
  * reverse() 메서드는 배열의 순서를 반전합니다. 첫 번째 요소는 마지막 요소가 되며 마지막 요소는 첫 번째 요소가 됩니다.  
  
`shift`
  * shift() 메서드는 배열에서 첫 번째 요소를 제거하고, 제거된 요소를 반환합니다. 이 메서드는 배열의 길이를 변하게 합니다.


`slice`
  * slice(begin,end) - 어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 바뀌지 않습니다.  
  
`sort`
  * 정렬합니다.
  * arr.sort(a,b,{compareFunction}) 형식  
  
`splice`
  * 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다.
  * `arr2 = arr.splice(4,0,'Test')` - arr의 4번째 index의 위치에 Test 추가 가운데 매개변수는 delete를 의미 0 이므로 삭제하지 않고 insert만 되는 것.
  * `arr3 = arr.splice(3,1)` - 3번째 요소 삭제한 배열 반환
    
`unshift`
  * 새로운 요소를 배열의 맨 앞쪽에 추가하고, 새로운 길이를 반환합니다.
  * `arr.unshift('test');`
  * 무한 스크롤을 할 때 유용
